// This file is auto-generated by @hey-api/openapi-ts

export namespace ai_service {
    export type AiServicePostSessionMessageBody = {
        message?: Message;
    };
    export type AutoConfig = {
        executeQuery?: boolean;
    };
    /**
     * - CHART_TYPE_UNSPECIFIED: Default unspecified type
     * - CHART_TYPE_TABLE: Tabular data visualization
     * - CHART_TYPE_LINE: Line chart
     * - CHART_TYPE_BAR: Bar chart
     * - CHART_TYPE_PIE: Pie chart
     */
    export type ChartType = 'CHART_TYPE_UNSPECIFIED' | 'CHART_TYPE_TABLE' | 'CHART_TYPE_LINE' | 'CHART_TYPE_BAR' | 'CHART_TYPE_PIE';
    /**
     * ChatSession represents an interactive conversation session with the AI. Messages in the session are ordered and accessed via cursor positions.
     */
    export type ChatSession = {
        messages?: Array<Message>;
        context?: Context;
        streaming?: boolean;
        preserveSession?: boolean;
    };
    export type Context = {
        projectOwner?: string;
        projectSlug?: string;
        version?: number;
        scenario?: ContextScenario;
        sqlConfig?: SqlConfig;
        insightConfig?: InsightConfig;
        autoConfig?: AutoConfig;
    };
    export type ContextScenario = 'SCENARIO_UNSPECIFIED' | 'SCENARIO_SQL' | 'SCENARIO_INSIGHT' | 'SCENARIO_AUTO';
    export type CreateChatSessionResponse = {
        sessionId?: string;
        currentCursorPosition?: number;
    };
    export type ErrorContent = {
        code?: string;
        message?: string;
    };
    export type InsightConfig = {
        executeQuery?: boolean;
    };
    export type InsightQueryContent = {
        explanation?: string;
        chartType?: ChartType;
        queries?: Array<common.Query>;
        formulas?: Array<common.Formula>;
        samplesLimit?: number;
        timeRange?: common.TimeRangeLite;
        results?: Array<InsightQueryResult>;
        title?: string;
    };
    export type InsightQueryResult = {
        id?: string;
        alias?: string;
        matrix?: common.Matrix;
        error?: string;
    };
    /**
     * Message represents a single message in an AI conversation with either text or structured content. Messages are generated as part of a 'run' (identified by run_id), and the is_final flag indicates when all messages for a run have been generated.
     */
    export type Message = {
        role?: MessageRole;
        text?: string;
        structured?: StructuredContent;
        isFinal?: boolean;
        runId?: string;
        resources?: Array<Resource>;
    };
    export type MessageRole = 'ROLE_UNSPECIFIED' | 'ROLE_USER' | 'ROLE_ASSISTANT' | 'ROLE_SYSTEM' | 'AI_ROLE_TOOL';
    export type PostSessionMessageResponse = {
        currentCursorPosition?: number;
    };
    export type Resource = {
        uri?: string;
        name?: string;
        description?: string;
        mimeType?: string;
        text?: string;
        blob?: string;
    };
    export type SqlConfig = {
        executeQuery?: boolean;
    };
    export type SqlContent = {
        query?: string;
        explanation?: string;
        chartType?: ChartType;
        title?: string;
        result?: common.TabularData;
        error?: string;
    };
    export type StructuredContent = {
        type?: StructuredContentContentType;
        sql?: SqlContent;
        insightQuery?: InsightQueryContent;
        error?: ErrorContent;
    };
    export type StructuredContentContentType = 'CONTENT_TYPE_UNSPECIFIED' | 'CONTENT_TYPE_SQL' | 'CONTENT_TYPE_INSIGHT_QUERY' | 'CONTENT_TYPE_ERROR';
    export type CreateChatSessionData = {
        /**
         * ChatSession represents an interactive conversation session with the AI. Messages in the session are ordered and accessed via cursor positions.
         */
        body: ai_service.ChatSession;
        path?: never;
        query?: never;
        url: '/v1/ai/chat';
    };
    export type CreateChatSessionResponses = {
        /**
         * A successful response.
         */
        200: ai_service.CreateChatSessionResponse;
    };
    export type CreateChatSessionResponse2 = CreateChatSessionResponses[keyof CreateChatSessionResponses];
    export type QueryChatSessionData = {
        body?: never;
        path: {
            /**
             * Unique identifier for the session
             */
            sessionId: string;
        };
        query?: {
            /**
             * Start cursor position - only messages after this position will be returned
             */
            cursorPosition?: number;
        };
        url: '/v1/ai/chat/{sessionId}';
    };
    export type QueryChatSessionResponses = {
        /**
         * A successful response.
         */
        200: ai_service.ChatSession;
    };
    export type QueryChatSessionResponse = QueryChatSessionResponses[keyof QueryChatSessionResponses];
    export type PostSessionMessageData = {
        body: ai_service.AiServicePostSessionMessageBody;
        path: {
            /**
             * Unique identifier for the session
             */
            sessionId: string;
        };
        query?: never;
        url: '/v1/ai/chat/{sessionId}/message';
    };
    export type PostSessionMessageResponses = {
        /**
         * A successful response.
         */
        200: ai_service.PostSessionMessageResponse;
    };
    export type PostSessionMessageResponse2 = PostSessionMessageResponses[keyof PostSessionMessageResponses];
}

export namespace alert_service {
    export type Alert = {
        id?: string;
        ruleId?: string;
        active?: boolean;
        query?: string;
        startTime?: string;
        endTime?: string;
        lastNotified?: string;
        createState?: AlertAlertState;
        lastState?: AlertAlertState;
    };
    export type AlertAlertState = {
        condition?: Condition;
        samples?: Array<Sample>;
        subject?: string;
        message?: string;
        logCondition?: LogCondition;
        logSamples?: Array<common.EventLogEntry>;
        time?: string;
        state?: AlertRuleState;
        queryTimeRange?: common.TimeRangeLite;
    };
    export type AlertRule = {
        id?: string;
        projectId?: string;
        state?: AlertRuleState;
        subject?: string;
        message?: string;
        group?: string;
        query?: string;
        for?: common.Duration;
        channels?: Array<common.Channel>;
        updateTime?: string;
        condition?: Condition;
        renotifyDuration?: common.Duration;
        renotifyLimit?: number;
        alertType?: AlertType;
        logCondition?: LogCondition;
        lastQueryTime?: string;
        mute?: boolean;
        interval?: common.Duration;
        error?: string;
    };
    export type AlertRuleState = 'NO_DATA' | 'FIRING' | 'NORMAL' | 'ERROR';
    export type AlertServiceSaveAlertRuleBody = {
        rule?: {
            projectId?: string;
            state?: AlertRuleState;
            subject?: string;
            message?: string;
            group?: string;
            query?: string;
            for?: common.Duration;
            channels?: Array<common.Channel>;
            updateTime?: string;
            condition?: Condition;
            renotifyDuration?: common.Duration;
            renotifyLimit?: number;
            alertType?: AlertType;
            logCondition?: LogCondition;
            lastQueryTime?: string;
            mute?: boolean;
            interval?: common.Duration;
            error?: string;
        };
    };
    export type AlertType = 'METRIC' | 'LOG';
    export type Condition = {
        queries?: Array<common.Query>;
        formula?: common.Formula;
        comparisonOp?: string;
        threshold?: number;
        eventsQueries?: Array<common.SegmentationQuery>;
        priceQueries?: Array<common.PriceSegmentationQuery>;
        insightQueries?: Array<ConditionInsightQuery>;
    };
    export type ConditionInsightQuery = {
        metricsQuery?: common.Query;
        eventsQuery?: common.SegmentationQuery;
        priceQuery?: common.PriceSegmentationQuery;
        sourceName?: string;
    };
    export type GetAlertResponse = {
        alertRule?: AlertRule;
        alerts?: Array<Alert>;
        mute?: Mute;
    };
    export type GetAlertRulesResponse = {
        rules?: Array<AlertRule>;
    };
    export type LogCondition = {
        query?: string;
        comparisonOp?: string;
        threshold?: number;
    };
    export type Mute = {
        id?: string;
        ruleId?: string;
        group?: string;
        active?: boolean;
        startTime?: string;
        endTime?: string;
        updateTime?: string;
    };
    export type Sample = {
        metric?: {
            [key: string]: string;
        };
        value?: number;
        timestamp?: string;
    };
    export type SaveAlertRuleRequest = {
        rule?: AlertRule;
    };
    export type SaveAlertRuleData = {
        body: alert_service.SaveAlertRuleRequest;
        path?: never;
        query?: never;
        url: '/v1/alerts/rule';
    };
    export type SaveAlertRuleResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type SaveAlertRuleResponse = SaveAlertRuleResponses[keyof SaveAlertRuleResponses];
    export type GetAlertRulesData = {
        body?: never;
        path: {
            projectId: string;
        };
        query?: never;
        url: '/v1/alerts/rule/project/{projectId}';
    };
    export type GetAlertRulesResponses = {
        /**
         * A successful response.
         */
        200: alert_service.GetAlertRulesResponse;
    };
    export type GetAlertRulesResponse2 = GetAlertRulesResponses[keyof GetAlertRulesResponses];
    export type SaveAlertRule2Data = {
        body: alert_service.AlertServiceSaveAlertRuleBody;
        path: {
            id: string;
        };
        query?: never;
        url: '/v1/alerts/rule/{id}';
    };
    export type SaveAlertRule2Responses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type SaveAlertRule2Response = SaveAlertRule2Responses[keyof SaveAlertRule2Responses];
    export type GetAlertData = {
        body?: never;
        path: {
            ruleId: string;
        };
        query?: {
            page?: number;
            pageSize?: number;
        };
        url: '/v1/alerts/{ruleId}';
    };
    export type GetAlertResponses = {
        /**
         * A successful response.
         */
        200: alert_service.GetAlertResponse;
    };
    export type GetAlertResponse2 = GetAlertResponses[keyof GetAlertResponses];
}

export namespace analytic_service {
    export type AnalyticServiceExecuteSqlAsyncBody = {
        projectId?: string;
        version?: number;
        sqlQuery?: SqlQuery;
        /**
         * Pagination cursor for the next page of results, using the value from the previous response.
         */
        cursor?: string;
        cachePolicy?: common.CachePolicy;
        engine?: ExecuteEngine;
    };
    export type AnalyticServiceExecuteSqlBody = {
        projectId?: string;
        version?: number;
        sqlQuery?: SqlQuery;
        /**
         * Pagination cursor for the next page of results, using the value from the previous response.
         */
        cursor?: string;
        cachePolicy?: common.CachePolicy;
        engine?: ExecuteEngine;
    };
    export type AnalyticServiceSaveRefreshableMaterializedViewBody = {
        projectId?: string;
        name?: string;
        sql?: string;
        refreshSettings?: ViewRefreshSettings;
    };
    export type AnalyticServiceSaveSqlBody = {
        projectId?: string;
        version?: number;
        sqlQuery?: SqlQuery;
        source?: Source;
    };
    export type AsyncExecuteSqlResponse = {
        queryId?: string;
        executionId?: string;
        queueLength?: number;
        computeStats?: common.ComputeStats;
    };
    export type ExecuteEngine = 'ULTRA' | 'SMALL' | 'MEDIUM' | 'LARGE';
    export type ExecutionInfo = {
        queryId?: string;
        executionId?: string;
        status?: ExecutionStatus;
        scheduledAt?: string;
        startedAt?: string;
        finishedAt?: string;
        result?: common.TabularData;
        error?: string;
        computeStats?: common.ComputeStats;
        processorVersion?: number;
    };
    export type ExecutionStatus = 'PENDING' | 'RUNNING' | 'FINISHED' | 'KILLED';
    export type GetRefreshableMaterializedViewStatusResponse = {
        name?: string;
        status?: string;
        lastRefreshTime?: string;
        lastSuccessTime?: string;
        nextRefreshTime?: string;
        progress?: string;
        readRows?: string;
        readBytes?: string;
        totalRows?: string;
        writtenRows?: string;
        writtenBytes?: string;
        sql?: string;
        refreshSettings?: ViewRefreshSettings;
        computeStats?: common.ComputeStats;
        exception?: string;
    };
    export type GetSharingSqlResponse = {
        query?: GetSharingSqlResponseQuery;
        project?: common.Project;
    };
    export type GetSharingSqlResponseQuery = {
        sqlQuery?: SqlQuery;
        createdAt?: string;
        updatedAt?: string;
    };
    export type ListRefreshableMaterializedViewResponse = {
        total?: string;
        views?: Array<ListRefreshableMaterializedViewResponseRefreshableMaterializedView>;
    };
    export type ListRefreshableMaterializedViewResponseRefreshableMaterializedView = {
        name?: string;
        sql?: string;
    };
    export type LogQueryRequestFilter = {
        field?: string;
        value?: string;
        not?: boolean;
    };
    export type LogQueryRequestSort = {
        field?: string;
        desc?: boolean;
    };
    export type LogQueryResponse = {
        entries?: Array<common.EventLogEntry>;
        after?: Array<common.Any>;
        total?: string;
    };
    export type QuerySqlExecutionDetailResponse = {
        computeStats?: common.ComputeStats;
    };
    export type QuerySqlResultResponse = {
        executionInfo?: ExecutionInfo;
    };
    export type QuerySegmentationResponse = {
        results?: Array<QuerySegmentationResponseResult>;
    };
    export type QuerySegmentationResponseResult = {
        matrix?: common.Matrix;
        error?: string;
        alias?: string;
        id?: string;
        computeStats?: common.ComputeStats;
        color?: string;
    };
    export type QueryTablesResponse = {
        tables?: {
            [key: string]: Table;
        };
        computeStats?: common.ComputeStats;
    };
    export type SqlQuery = {
        sql?: string;
        size?: number;
        parameters?: common.RichStruct;
        /**
         * the name of the query, if sql is empty and name not empty, the query will be fetched by the name.
         */
        name?: string;
        /**
         * the id of the query, if sql and name both empty, the query will be fetched by the id.
         */
        queryId?: string;
    };
    export type SaveRefreshableMaterializedViewResponse = {
        name?: string;
        isUpdated?: boolean;
    };
    export type SaveSqlResponse = {
        queryId?: string;
    };
    export type SaveSharingSqlRequest = {
        queryId?: string;
        isPublic?: boolean;
    };
    export type SaveSharingSqlResponse = {
        sharingId?: string;
        queryId?: string;
        isPublic?: boolean;
        createdAt?: string;
        updatedAt?: string;
    };
    export type SearchServiceQueryLogBody = {
        projectId?: string;
        query?: string;
        timeRange?: common.TimeRange;
        sorts?: Array<LogQueryRequestSort>;
        after?: Array<common.Any>;
        limit?: number;
        offset?: number;
        filters?: Array<LogQueryRequestFilter>;
        version?: number;
        source?: string;
    };
    export type SegmentationRequest = {
        projectOwner?: string;
        projectSlug?: string;
        projectId?: string;
        version?: number;
        timeRange?: common.TimeRangeLite;
        queries?: Array<common.SegmentationQuery>;
        formulas?: Array<common.Formula>;
        debug?: boolean;
        limit?: number;
        offset?: number;
    };
    export type Source = 'SQL_EDITOR' | 'DASHBOARD' | 'ASYNC_TRIGGER' | 'CURL' | 'ENDPOINT';
    export type SyncExecuteSqlResponse = {
        runtimeCost?: string;
        result?: common.TabularData;
        error?: string;
        computeStats?: common.ComputeStats;
    };
    export type Table = {
        name?: string;
        columns?: {
            [key: string]: TableColumn;
        };
        tableType?: TableTableType;
        relatedProjectId?: string;
    };
    export type TableColumn = {
        name?: string;
        columnType?: TableColumnColumnType;
        clickhouseDataType?: string;
        isBuiltin?: boolean;
    };
    export type TableColumnColumnType = 'STRING' | 'NUMBER' | 'BOOLEAN' | 'LIST' | 'TIME' | 'JSON' | 'TOKEN';
    export type TableTableType = 'RESERVED' | 'EVENT' | 'METRICS' | 'SUBGRAPH' | 'MATERIALIZED_VIEW' | 'IMPORTED_EVENT' | 'SYSTEM' | 'ENTITY' | 'IMPORTED_ENTITY' | 'IMPORTED_SUBGRAPH' | 'USER_REFRESHABLE_VIEW' | 'DASH_COMMUNITY_EVENT' | 'DASH_COMMUNITY_SUBGRAPH' | 'DASH_COMMUNITY_ENTITY' | 'DASH_CURATED_EVENT' | 'DASH_CURATED_SUBGRAPH' | 'DASH_CURATED_ENTITY' | 'DASH_COMMUNITY_MATERIALIZED_VIEW' | 'DASH_CURATED_MATERIALIZED_VIEW';
    export type ViewRefreshSettings = {
        refreshInterval?: string;
        strategy?: ViewRefreshSettingsRefreshStrategy;
        dependsOn?: Array<string>;
        appendMode?: boolean;
        orderBy?: string;
    };
    export type ViewRefreshSettingsRefreshStrategy = 'EVERY' | 'AFTER';
    export type SaveSharingSqlData = {
        body: analytic_service.SaveSharingSqlRequest;
        path?: never;
        query?: never;
        url: '/v1/analytics/sql/sharing';
    };
    export type SaveSharingSqlResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.SaveSharingSqlResponse;
    };
    export type SaveSharingSqlResponse2 = SaveSharingSqlResponses[keyof SaveSharingSqlResponses];
    export type GetSharingSqlData = {
        body?: never;
        path: {
            id: string;
        };
        query?: never;
        url: '/v1/analytics/sql/sharing/{id}';
    };
    export type GetSharingSqlResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.GetSharingSqlResponse;
    };
    export type GetSharingSqlResponse2 = GetSharingSqlResponses[keyof GetSharingSqlResponses];
    export type QueryTables2Data = {
        body?: never;
        path?: never;
        query?: {
            projectOwner?: string;
            projectSlug?: string;
            projectId?: string;
            version?: number;
            includeChains?: boolean;
            includeViews?: boolean;
            includeExternals?: boolean;
            includeDash?: boolean;
        };
        url: '/v1/analytics/sql/tables';
    };
    export type QueryTables2Responses = {
        /**
         * A successful response.
         */
        200: analytic_service.QueryTablesResponse;
    };
    export type QueryTables2Response = QueryTables2Responses[keyof QueryTables2Responses];
    export type ExecuteSqlData = {
        body: analytic_service.AnalyticServiceExecuteSqlBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/analytics/{owner}/{slug}/sql/execute';
    };
    export type ExecuteSqlResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.SyncExecuteSqlResponse;
    };
    export type ExecuteSqlResponse = ExecuteSqlResponses[keyof ExecuteSqlResponses];
    export type ExecuteSqlAsyncData = {
        body: analytic_service.AnalyticServiceExecuteSqlAsyncBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/analytics/{owner}/{slug}/sql/execute/async';
    };
    export type ExecuteSqlAsyncResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.AsyncExecuteSqlResponse;
    };
    export type ExecuteSqlAsyncResponse = ExecuteSqlAsyncResponses[keyof ExecuteSqlAsyncResponses];
    export type QuerySqlExecutionDetailData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            executionId: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
            /**
             * version of the datasource, default to the active version if not provided
             */
            version?: number;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/query_execution_detail/{executionId}';
    };
    export type QuerySqlExecutionDetailResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.QuerySqlExecutionDetailResponse;
    };
    export type QuerySqlExecutionDetailResponse2 = QuerySqlExecutionDetailResponses[keyof QuerySqlExecutionDetailResponses];
    export type QuerySqlResultData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            executionId: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
            /**
             * version of the datasource, default to the active version if not provided
             */
            version?: number;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/query_result/{executionId}';
    };
    export type QuerySqlResultResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.QuerySqlResultResponse;
    };
    export type QuerySqlResultResponse2 = QuerySqlResultResponses[keyof QuerySqlResultResponses];
    export type SaveRefreshableMaterializedViewData = {
        body: analytic_service.AnalyticServiceSaveRefreshableMaterializedViewBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/analytics/{owner}/{slug}/sql/refreshable_materialized_view';
    };
    export type SaveRefreshableMaterializedViewResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.SaveRefreshableMaterializedViewResponse;
    };
    export type SaveRefreshableMaterializedViewResponse2 = SaveRefreshableMaterializedViewResponses[keyof SaveRefreshableMaterializedViewResponses];
    export type GetRefreshableMaterializedStatusData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            name: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/refreshable_materialized_view/{name}';
    };
    export type GetRefreshableMaterializedStatusResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.GetRefreshableMaterializedViewStatusResponse;
    };
    export type GetRefreshableMaterializedStatusResponse = GetRefreshableMaterializedStatusResponses[keyof GetRefreshableMaterializedStatusResponses];
    export type ListRefreshableMaterializedViewsData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/refreshable_materialized_views';
    };
    export type ListRefreshableMaterializedViewsResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.ListRefreshableMaterializedViewResponse;
    };
    export type ListRefreshableMaterializedViewsResponse = ListRefreshableMaterializedViewsResponses[keyof ListRefreshableMaterializedViewsResponses];
    export type SaveSqlData = {
        body: analytic_service.AnalyticServiceSaveSqlBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/analytics/{owner}/{slug}/sql/save';
    };
    export type SaveSqlResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.SaveSqlResponse;
    };
    export type SaveSqlResponse2 = SaveSqlResponses[keyof SaveSqlResponses];
    export type SaveSql2Data = {
        body: analytic_service.AnalyticServiceSaveSqlBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/analytics/{owner}/{slug}/sql/save';
    };
    export type SaveSql2Responses = {
        /**
         * A successful response.
         */
        200: analytic_service.SaveSqlResponse;
    };
    export type SaveSql2Response = SaveSql2Responses[keyof SaveSql2Responses];
    export type QueryTablesData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            projectId?: string;
            version?: number;
            includeChains?: boolean;
            includeViews?: boolean;
            includeExternals?: boolean;
            includeDash?: boolean;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/tables';
    };
    export type QueryTablesResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.QueryTablesResponse;
    };
    export type QueryTablesResponse2 = QueryTablesResponses[keyof QueryTablesResponses];
    export type QueryLogData = {
        body: analytic_service.SearchServiceQueryLogBody;
        path: {
            owner: string;
            slug: string;
        };
        query?: never;
        url: '/v1/eventlogs/{owner}/{slug}';
    };
    export type QueryLogResponses = {
        /**
         * A successful response.
         */
        200: analytic_service.LogQueryResponse;
    };
    export type QueryLogResponse = QueryLogResponses[keyof QueryLogResponses];
    export type QueryLog2Data = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            projectId?: string;
            query?: string;
            'timeRange.start.relativeTime.unit'?: string;
            'timeRange.start.relativeTime.value'?: number;
            'timeRange.start.relativeTime.align'?: string;
            'timeRange.start.absoluteTime'?: string;
            'timeRange.end.relativeTime.unit'?: string;
            'timeRange.end.relativeTime.value'?: number;
            'timeRange.end.relativeTime.align'?: string;
            'timeRange.end.absoluteTime'?: string;
            'timeRange.step'?: string;
            'timeRange.interval.value'?: number;
            'timeRange.interval.unit'?: string;
            'timeRange.timezone'?: string;
            limit?: number;
            offset?: number;
            version?: number;
            source?: string;
        };
        url: '/v1/eventlogs/{owner}/{slug}/query';
    };
    export type QueryLog2Responses = {
        /**
         * A successful response.
         */
        200: analytic_service.LogQueryResponse;
    };
    export type QueryLog2Response = QueryLog2Responses[keyof QueryLog2Responses];
}

export namespace common {
    export type Aggregate = {
        op?: AggregateAggregateOps;
        grouping?: Array<string>;
    };
    export type AggregateAggregateOps = 'AVG' | 'SUM' | 'MIN' | 'MAX' | 'COUNT';
    export type Any = {
        intValue?: number;
        longValue?: string;
        doubleValue?: number;
        stringValue?: string;
        boolValue?: boolean;
        dateValue?: string;
        listValue?: StringList;
    };
    export type Argument = {
        stringValue?: string;
        intValue?: number;
        doubleValue?: number;
        boolValue?: boolean;
        durationValue?: Duration;
    };
    export type BigDecimal = {
        value?: BigInteger;
        exp?: number;
    };
    export type BigInteger = {
        negative?: boolean;
        data?: string;
    };
    export type CachePolicy = {
        cacheTtlSecs?: number;
        cacheRefreshTtlSecs?: number;
        forceRefresh?: boolean;
        noCache?: boolean;
    };
    export type Channel = {
        id?: string;
        projectId?: string;
        type?: ChannelType;
        slackWebhookUrl?: string;
        emailAddress?: string;
        name?: string;
        customWebhookUrl?: string;
        customHeaders?: {
            [key: string]: string;
        };
        telegramReference?: string;
        telegramChatId?: string;
        slackTeam?: string;
        slackChannel?: string;
        pagerdutyConfig?: {
            [key: string]: unknown;
        };
    };
    export type ChannelType = 'UNKNOWN' | 'EMAIL' | 'SLACK' | 'TELEGRAM' | 'WEBHOOK' | 'DISCORD' | 'PAGERDUTY';
    export type CohortsFilter = {
        symbol?: boolean;
        name?: string;
        aggregation?: CohortsFilterAggregation;
        selectorExpr?: SelectorExpr;
        timeRange?: TimeRangeLite;
    };
    export type CohortsFilterAggregation = {
        total?: CohortsFilterAggregationTotal;
        aggregateProperties?: CohortsFilterAggregationAggregateProperties;
        operator?: CohortsFilterAggregationOperatorType;
        value?: Array<Any>;
    };
    export type CohortsFilterAggregationAggregateProperties = {
        type?: CohortsFilterAggregationAggregatePropertiesAggregationType;
        propertyName?: string;
    };
    export type CohortsFilterAggregationAggregatePropertiesAggregationType = 'SUM' | 'AVG' | 'MEDIAN' | 'MIN' | 'MAX' | 'DISTINCT_COUNT' | 'LAST' | 'FIRST';
    export type CohortsFilterAggregationOperatorType = 'EQ' | 'NEQ' | 'GT' | 'GTE' | 'LT' | 'LTE' | 'BETWEEN' | 'NOT_BETWEEN';
    export type CohortsFilterAggregationTotal = {
        [key: string]: unknown;
    };
    export type CohortsGroup = {
        joinOperator?: JoinOperator;
        filters?: Array<CohortsFilter>;
    };
    export type CohortsQuery = {
        joinOperator?: JoinOperator;
        groups?: Array<CohortsGroup>;
        name?: string;
        id?: string;
    };
    export type CoinId = {
        symbol?: string;
        address?: CoinIdAddressIdentifier;
    };
    export type CoinIdAddressIdentifier = {
        address?: string;
        chain?: string;
    };
    export type ColumnState = {
        columnSizing?: {
            [key: string]: number;
        };
        columnVisibility?: {
            [key: string]: boolean;
        };
        columnOrder?: Array<string>;
        sorting?: Array<ColumnStateSort>;
    };
    export type ColumnStateSort = {
        id?: string;
        desc?: boolean;
    };
    export type CommunityProject = {
        dashAlias?: string;
        curated?: boolean;
        chain?: {
            [key: string]: StringList;
        };
    };
    export type ComputeStats = {
        computedAt?: string;
        computeCostMs?: string;
        binaryVersionHash?: string;
        computedBy?: string;
        isCached?: boolean;
        isRefreshing?: boolean;
        clickhouseStats?: ComputeStatsClickhouseStats;
    };
    export type ComputeStatsClickhouseStats = {
        readRows?: string;
        readBytes?: string;
        memoryUsage?: string;
        queryDurationMs?: string;
        resultRows?: string;
        resultBytes?: string;
    };
    export type Duration = {
        value?: number;
        unit?: string;
    };
    export type ErrorRecord = {
        id?: string;
        namespace?: number;
        code?: number;
        namespaceCode?: number;
        message?: string;
        createdAt?: string;
    };
    export type EventLogColumn = {
        id?: string;
        size?: number;
        name?: string;
        accessorKey?: string;
        enableHiding?: boolean;
        enableSorting?: boolean;
        enableResizing?: boolean;
    };
    export type EventLogConfig = {
        columns?: Array<EventLogColumn>;
        state?: ColumnState;
    };
    export type EventLogEntry = {
        message?: string;
        timestamp?: string;
        logLevel?: string;
        logType?: string;
        contractName?: string;
        contractAddress?: string;
        blockNumber?: string;
        chainId?: string;
        attributes?: {
            [key: string]: unknown;
        };
        id?: string;
        transactionHash?: string;
        highlightedMessage?: string;
        distinctId?: string;
        eventName?: string;
        logIndex?: number;
        transactionIndex?: number;
    };
    /**
     * the formula to combine multiple queries
     */
    export type Formula = {
        expression?: string;
        alias?: string;
        id?: string;
        disabled?: boolean;
        functions?: Array<_Function>;
        color?: string;
    };
    export type _Function = {
        name?: string;
        arguments?: Array<Argument>;
    };
    export type ImportedProject = {
        name?: string;
        project?: Project;
        imported?: Project;
    };
    export type JoinOperator = 'AND' | 'OR' | 'THEN';
    export type Matrix = {
        samples?: Array<MatrixSample>;
        totalSamples?: number;
    };
    export type MatrixMetric = {
        name?: string;
        labels?: {
            [key: string]: string;
        };
        displayName?: string;
    };
    export type MatrixSample = {
        metric?: MatrixMetric;
        values?: Array<MatrixValue>;
    };
    export type MatrixValue = {
        timestamp?: string;
        value?: number;
    };
    export type Organization = {
        id?: string;
        oid?: string;
        name?: string;
        createdAt?: string;
        updatedAt?: string;
        members?: Array<OrganizationMember>;
        displayName?: string;
        logoUrl?: string;
        projects?: Array<ProjectInfo>;
        tier?: Tier;
    };
    export type OrganizationMember = {
        user?: UserInfo;
        role?: OrganizationRole;
    };
    export type OrganizationRole = 'ORG_MEMBER' | 'ORG_ADMIN';
    export type Owner = {
        user?: User;
        organization?: Organization;
        tier?: Tier;
    };
    export type Permission = 'READ' | 'WRITE' | 'ADMIN';
    export type PriceSegmentationQuery = {
        id?: string;
        alias?: string;
        coinId?: Array<CoinId>;
        color?: string;
        disabled?: boolean;
    };
    export type Project = {
        id?: string;
        displayName?: string;
        description?: string;
        createdAt?: string;
        updatedAt?: string;
        slug?: string;
        ownerId?: string;
        owner?: Owner;
        visibility?: ProjectVisibility;
        type?: ProjectType;
        members?: Array<ProjectProjectMember>;
        multiVersion?: boolean;
        ownerName?: string;
        notificationChannels?: Array<Channel>;
        views?: Array<ProjectView>;
        supersetEnable?: boolean;
        superset?: ProjectSuperset;
        enableDisk?: boolean;
        enableMaterializedView?: boolean;
        defaultTimerange?: TimeRangeLite;
        communityProject?: CommunityProject;
    };
    export type ProjectProjectMember = {
        user?: UserInfo;
        role?: string;
    };
    export type ProjectType = 'SENTIO' | 'SUBGRAPH' | 'ACTION';
    export type ProjectVisibility = 'PUBLIC' | 'PRIVATE';
    export type ProjectInfo = {
        id?: string;
        displayName?: string;
        description?: string;
        createdAt?: string;
        updatedAt?: string;
        slug?: string;
        owner?: string;
        visibility?: ProjectVisibility;
        type?: ProjectType;
        multiVersion?: boolean;
        supersetEnable?: boolean;
        superset?: ProjectSuperset;
        enableDisk?: boolean;
        enableMaterializedView?: boolean;
        defaultTimerange?: TimeRangeLite;
    };
    export type ProjectSuperset = {
        projectId?: string;
        createdAt?: string;
        syncAt?: string;
    };
    export type ProjectVariables = {
        projectId?: string;
        variables?: Array<ProjectVariablesVariable>;
    };
    export type ProjectVariablesVariable = {
        key?: string;
        value?: string;
        isSecret?: boolean;
        updatedAt?: string;
    };
    export type ProjectView = {
        id?: string;
        projectId?: string;
        name?: string;
        config?: ProjectViewProjectViewConfig;
    };
    export type ProjectViewProjectViewConfig = {
        eventLog?: EventLogConfig;
    };
    /**
     * the query to fetch metrics data, promql
     */
    export type Query = {
        query?: string;
        alias?: string;
        id?: string;
        labelSelector?: {
            [key: string]: string;
        };
        aggregate?: Aggregate;
        functions?: Array<_Function>;
        color?: string;
        disabled?: boolean;
    };
    export type RetentionQuery = {
        resources?: Array<RetentionQueryResource>;
        criteria?: RetentionQueryCriteria;
        interval?: RetentionQueryInterval;
        selectorExpr?: SelectorExpr;
        groupBy?: Array<string>;
        segmentBy?: Array<SegmentParameter>;
        windowSize?: number;
    };
    export type RetentionQueryCriteria = 'OnOrAfter' | 'On';
    export type RetentionQueryFilter = {
        propertyFilter?: SelectorExpr;
        timeFilter?: RetentionQueryFilterTimeFilter;
    };
    export type RetentionQueryFilterTimeFilter = {
        type?: RetentionQueryFilterTimeFilterType;
    };
    export type RetentionQueryFilterTimeFilterType = 'Disable' | 'FirstInTimeRange' | 'FirstInGlobal';
    export type RetentionQueryInterval = {
        value?: number;
        unit?: RetentionQueryIntervalUnit;
    };
    export type RetentionQueryIntervalUnit = 'Day' | 'Week' | 'Month';
    export type RetentionQueryResource = {
        eventNames?: Array<string>;
        filter?: RetentionQueryFilter;
    };
    export type RichStruct = {
        fields?: {
            [key: string]: RichValue;
        };
    };
    export type RichValue = {
        nullValue?: RichValueNullValue;
        intValue?: number;
        int64Value?: string;
        floatValue?: number;
        bytesValue?: string;
        boolValue?: boolean;
        stringValue?: string;
        timestampValue?: string;
        bigintValue?: BigInteger;
        bigdecimalValue?: BigDecimal;
        listValue?: RichValueList;
        structValue?: RichStruct;
        tokenValue?: TokenAmount;
    };
    export type RichValueNullValue = 'NULL_VALUE';
    export type RichValueList = {
        values?: Array<RichValue>;
    };
    export type SegmentParameter = {
        cohortId?: string;
        allUsers?: boolean;
    };
    export type SegmentationQuery = {
        resource?: SegmentationQueryResource;
        alias?: string;
        id?: string;
        aggregation?: SegmentationQueryAggregation;
        selectorExpr?: SegmentationQuerySelectorExpr;
        groupBy?: Array<string>;
        limit?: number;
        functions?: Array<_Function>;
        color?: string;
        disabled?: boolean;
    };
    export type SegmentationQueryAggregation = {
        total?: SegmentationQueryAggregationTotal;
        unique?: SegmentationQueryAggregationUnique;
        countUnique?: SegmentationQueryAggregationCountUnique;
        aggregateProperties?: SegmentationQueryAggregationAggregateProperties;
    };
    export type SegmentationQueryAggregationAggregateProperties = {
        type?: SegmentationQueryAggregationAggregatePropertiesAggregationType;
        propertyName?: string;
    };
    export type SegmentationQueryAggregationAggregatePropertiesAggregationType = 'SUM' | 'CUMULATIVE_SUM' | 'AVG' | 'MEDIAN' | 'MIN' | 'MAX' | 'DISTINCT_COUNT' | 'CUMULATIVE_DISTINCT_COUNT' | 'CUMULATIVE_COUNT' | 'LAST' | 'CUMULATIVE_LAST' | 'FIRST' | 'CUMULATIVE_FIRST' | 'PERCENTILE_25TH' | 'PERCENTILE_75TH' | 'PERCENTILE_90TH' | 'PERCENTILE_95TH' | 'PERCENTILE_99TH';
    export type SegmentationQueryAggregationCountUnique = {
        duration?: Duration;
    };
    export type SegmentationQueryAggregationTotal = {
        [key: string]: unknown;
    };
    export type SegmentationQueryAggregationUnique = {
        [key: string]: unknown;
    };
    export type SegmentationQueryResource = {
        name?: string;
        type?: SegmentationQueryResourceType;
        cohortsId?: string;
        cohortsQuery?: CohortsQuery;
    };
    export type SegmentationQueryResourceType = 'EVENTS' | 'COHORTS';
    export type SegmentationQuerySelectorExpr = {
        selector?: Selector;
        logicExpr?: SegmentationQuerySelectorExprLogicExpr;
    };
    export type SegmentationQuerySelectorExprLogicExpr = {
        expressions?: Array<SegmentationQuerySelectorExpr>;
        operator?: JoinOperator;
    };
    export type Selector = {
        key?: string;
        operator?: SelectorOperatorType;
        value?: Array<Any>;
    };
    export type SelectorOperatorType = 'EQ' | 'NEQ' | 'EXISTS' | 'NOT_EXISTS' | 'GT' | 'GTE' | 'LT' | 'LTE' | 'BETWEEN' | 'NOT_BETWEEN' | 'CONTAINS' | 'NOT_CONTAINS' | 'IN' | 'NOT_IN' | 'IN_COHORTS' | 'NOT_IN_COHORTS';
    export type SelectorExpr = {
        selector?: Selector;
        logicExpr?: SelectorExprLogicExpr;
    };
    export type SelectorExprLogicExpr = {
        expressions?: Array<SelectorExpr>;
        operator?: JoinOperator;
    };
    export type StringList = {
        values?: Array<string>;
    };
    export type TabularData = {
        columns?: Array<string>;
        columnTypes?: {
            [key: string]: TabularDataColumnType;
        };
        rows?: Array<{
            [key: string]: unknown;
        }>;
        generatedAt?: string;
        /**
         * The pagination cursor for the next page of results. If present, use this value in the `cursor` field of the next request to retrieve subsequent data. If null or empty, there are no more results.
         */
        cursor?: string;
    };
    export type TabularDataColumnType = 'STRING' | 'NUMBER' | 'BOOLEAN' | 'LIST' | 'TIME' | 'MAP' | 'JSON' | 'TOKEN' | 'DYNAMIC';
    export type Tier = 'FREE' | 'DEV' | 'PRO' | 'ENTERPRISE' | 'ANONYMOUS';
    export type TimeRange = {
        start?: TimeRangeTimeLike;
        end?: TimeRangeTimeLike;
        step?: string;
        interval?: Duration;
        timezone?: string;
    };
    export type TimeRangeRelativeTime = {
        unit?: string;
        value?: number;
        align?: string;
    };
    export type TimeRangeTimeLike = {
        relativeTime?: TimeRangeRelativeTime;
        absoluteTime?: string;
    };
    /**
     * start and end time of the time range, Find more: https://docs.sentio.xyz/reference/data#time-range-configuration-guide
     */
    export type TimeRangeLite = {
        start: string;
        end: string;
        step: number;
        timezone?: string;
    };
    export type TokenAmount = {
        token?: CoinId;
        amount?: BigDecimal;
        specifiedAt?: string;
    };
    export type User = {
        id?: string;
        email?: string;
        emailVerified?: boolean;
        lastName?: string;
        firstName?: string;
        locale?: string;
        nickname?: string;
        picture?: string;
        sub?: string;
        updatedAt?: string;
        createdAt?: string;
        username?: string;
        accountStatus?: UserAccountStatus;
        tier?: Tier;
        isOrganization?: boolean;
        walletAddress?: string;
        identities?: Array<string>;
    };
    export type UserAccountStatus = 'PENDING' | 'SET_USERNAME' | 'BANNED' | 'ACTIVE';
    /**
     * The same to user but with sensitive data removed.
     */
    export type UserInfo = {
        id?: string;
        lastName?: string;
        firstName?: string;
        nickname?: string;
        picture?: string;
        username?: string;
    };
    export type GetProjectByIdData = {
        body?: never;
        path: {
            projectId: string;
        };
        query?: never;
        url: '/v1/project/{projectId}';
    };
    export type GetProjectByIdResponses = {
        /**
         * A successful response.
         */
        200: common.ProjectInfo;
    };
    export type GetProjectByIdResponse = GetProjectByIdResponses[keyof GetProjectByIdResponses];
}

export namespace evm {
    export type AccessListItem = {
        address?: string;
        storageKeys?: Array<string>;
    };
    export type Transaction = {
        blockNumber?: string;
        blockHash?: string;
        transactionIndex?: string;
        hash?: string;
        chainId?: string;
        type?: string;
        from?: string;
        to?: string;
        input?: string;
        value?: string;
        nonce?: string;
        gas?: string;
        gasPrice?: string;
        maxFeePerGas?: string;
        maxPriorityFeePerGas?: string;
        accessList?: Array<AccessListItem>;
    };
    export type TransactionReceipt = {
        gasUsed?: string;
        cumulativeGasUsed?: string;
        effectiveGasPrice?: string;
        status?: string;
        error?: string;
        revertReason?: string;
        logs?: Array<{
            [key: string]: unknown;
        }>;
    };
}

export namespace google {
    export type ApiHttpBody = {
        contentType?: string;
        data?: string;
        extensions?: Array<ProtobufAny>;
    };
    /**
     * `Any` contains an arbitrary serialized protocol buffer message along with a
     * URL that describes the type of the serialized message.
     *
     * Protobuf library provides support to pack/unpack Any values in the form
     * of utility functions or additional generated methods of the Any type.
     *
     * Example 1: Pack and unpack a message in C++.
     *
     * Foo foo = ...;
     * Any any;
     * any.PackFrom(foo);
     * ...
     * if (any.UnpackTo(&foo)) {
     * ...
     * }
     *
     * Example 2: Pack and unpack a message in Java.
     *
     * Foo foo = ...;
     * Any any = Any.pack(foo);
     * ...
     * if (any.is(Foo.class)) {
     * foo = any.unpack(Foo.class);
     * }
     * // or ...
     * if (any.isSameTypeAs(Foo.getDefaultInstance())) {
     * foo = any.unpack(Foo.getDefaultInstance());
     * }
     *
     * Example 3: Pack and unpack a message in Python.
     *
     * foo = Foo(...)
     * any = Any()
     * any.Pack(foo)
     * ...
     * if any.Is(Foo.DESCRIPTOR):
     * any.Unpack(foo)
     * ...
     *
     * Example 4: Pack and unpack a message in Go
     *
     * foo := &pb.Foo{...}
     * any, err := anypb.New(foo)
     * if err != nil {
     * ...
     * }
     * ...
     * foo := &pb.Foo{}
     * if err := any.UnmarshalTo(foo); err != nil {
     * ...
     * }
     *
     * The pack methods provided by protobuf library will by default use
     * 'type.googleapis.com/full.type.name' as the type URL and the unpack
     * methods only use the fully qualified type name after the last '/'
     * in the type URL, for example "foo.bar.com/x/y.z" will yield type
     * name "y.z".
     *
     * JSON
     * ====
     * The JSON representation of an `Any` value uses the regular
     * representation of the deserialized, embedded message, with an
     * additional field `@type` which contains the type URL. Example:
     *
     * package google.profile;
     * message Person {
     * string first_name = 1;
     * string last_name = 2;
     * }
     *
     * {
     * "@type": "type.googleapis.com/google.profile.Person",
     * "firstName": <string>,
     * "lastName": <string>
     * }
     *
     * If the embedded message type is well-known and has a custom JSON
     * representation, that representation will be embedded adding a field
     * `value` which holds the custom JSON in addition to the `@type`
     * field. Example (for message [google.protobuf.Duration][]):
     *
     * {
     * "@type": "type.googleapis.com/google.protobuf.Duration",
     * "value": "1.212s"
     * }
     */
    export type ProtobufAny = {
        /**
         * A URL/resource name that uniquely identifies the type of the serialized
         * protocol buffer message. This string must contain at least
         * one "/" character. The last segment of the URL's path must represent
         * the fully qualified name of the type (as in
         * `path/google.protobuf.Duration`). The name should be in a canonical form
         * (e.g., leading "." is not accepted).
         *
         * In practice, teams usually precompile into the binary all types that they
         * expect it to use in the context of Any. However, for URLs which use the
         * scheme `http`, `https`, or no scheme, one can optionally set up a type
         * server that maps type URLs to message definitions as follows:
         *
         * * If no scheme is provided, `https` is assumed.
         * * An HTTP GET on the URL must yield a [google.protobuf.Type][]
         * value in binary format, or produce an error.
         * * Applications are allowed to cache lookup results based on the
         * URL, or have them precompiled into a binary to avoid any
         * lookup. Therefore, binary compatibility needs to be preserved
         * on changes to types. (Use versioned type names to manage
         * breaking changes.)
         *
         * Note: this functionality is not currently available in the official
         * protobuf release, and it is not used for type URLs beginning with
         * type.googleapis.com. As of May 2023, there are no widely used type server
         * implementations and no plans to implement one.
         *
         * Schemes other than `http`, `https` (or the empty scheme) might be
         * used with implementation specific semantics.
         */
        '@type'?: string;
        [key: string]: unknown | string | undefined;
    };
    /**
     * `NullValue` is a singleton enumeration to represent the null value for the
     * `Value` type union.
     *
     * The JSON representation for `NullValue` is JSON `null`.
     *
     * - NULL_VALUE: Null value.
     */
    export type ProtobufNullValue = 'NULL_VALUE';
    export type GetCallTraceOnForkBundleData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            forkId: string;
            bundleId: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/fork/{forkId}/bundle/{bundleId}/call_trace';
    };
    export type GetCallTraceOnForkBundleResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceOnForkBundleResponse = GetCallTraceOnForkBundleResponses[keyof GetCallTraceOnForkBundleResponses];
    export type GetCallTraceOnForkSimulationData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            forkId: string;
            simulationId: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/fork/{forkId}/simulation/{simulationId}/call_trace';
    };
    export type GetCallTraceOnForkSimulationResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceOnForkSimulationResponse = GetCallTraceOnForkSimulationResponses[keyof GetCallTraceOnForkSimulationResponses];
    export type GetCallTraceOnForkTransactionData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            forkId: string;
            txHash: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/fork/{forkId}/transaction/{txHash}/call_trace';
    };
    export type GetCallTraceOnForkTransactionResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceOnForkTransactionResponse = GetCallTraceOnForkTransactionResponses[keyof GetCallTraceOnForkTransactionResponses];
    export type GetCallTraceByBundleData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            chainId: string;
            bundleId: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/{chainId}/bundle/{bundleId}/call_trace';
    };
    export type GetCallTraceByBundleResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceByBundleResponse = GetCallTraceByBundleResponses[keyof GetCallTraceByBundleResponses];
    export type GetCallTraceBySimulationData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            chainId: string;
            simulationId: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/{chainId}/simulation/{simulationId}/call_trace';
    };
    export type GetCallTraceBySimulationResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceBySimulationResponse = GetCallTraceBySimulationResponses[keyof GetCallTraceBySimulationResponses];
    export type GetCallTraceByTransactionData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            chainId: string;
            txHash: string;
        };
        query?: {
            /**
             * Fetch the decoded trace, which will give you the function info, decoded parameters of both external and internal call trace.
             */
            withInternalCalls?: boolean;
            /**
             * Disable optimizations to make internal calls more accurate, but gas costs will differ from the actual execution.
             */
            disableOptimizer?: boolean;
            /**
             * Only effective when disableOptimizer=true.
             */
            ignoreGasCost?: boolean;
        };
        url: '/v1/solidity/{owner}/{slug}/{chainId}/transaction/{txHash}/call_trace';
    };
    export type GetCallTraceByTransactionResponses = {
        /**
         * A successful response.
         */
        200: google.ApiHttpBody;
    };
    export type GetCallTraceByTransactionResponse = GetCallTraceByTransactionResponses[keyof GetCallTraceByTransactionResponses];
}

export namespace insights_service {
    export type DataSource = 'METRICS' | 'EVENTS' | 'PRICE' | 'FORMULA' | 'COHORTS' | 'SYSTEM_SQL';
    export type InsightsServiceQueryBody = {
        projectId?: string;
        version?: number;
        timeRange?: common.TimeRangeLite;
        queries?: Array<QueryRequestQuery>;
        formulas?: Array<common.Formula>;
        limit?: number;
        offset?: number;
        bypassCache?: boolean;
        cachePolicy?: common.CachePolicy;
    };
    export type ListCoinsResponse = {
        coins?: Array<common.CoinId>;
        computeStats?: common.ComputeStats;
    };
    export type QueryRequestQuery = {
        metricsQuery?: common.Query;
        eventsQuery?: common.SegmentationQuery;
        priceQuery?: common.PriceSegmentationQuery;
        dataSource?: DataSource;
        sourceName?: string;
    };
    export type QueryResponse = {
        results?: Array<QueryResponseResult>;
    };
    export type QueryResponseResult = {
        id?: string;
        alias?: string;
        dataSource?: DataSource;
        matrix?: common.Matrix;
        error?: string;
        computeStats?: common.ComputeStats;
        color?: string;
    };
    export type ListCoins2Data = {
        body?: never;
        path?: never;
        query?: {
            projectOwner?: string;
            projectSlug?: string;
            projectId?: string;
            version?: number;
            limit?: number;
            offset?: number;
            searchQuery?: string;
        };
        url: '/v1/insights/coins';
    };
    export type ListCoins2Responses = {
        /**
         * A successful response.
         */
        200: insights_service.ListCoinsResponse;
    };
    export type ListCoins2Response = ListCoins2Responses[keyof ListCoins2Responses];
    export type ListCoinsData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            projectId?: string;
            version?: number;
            limit?: number;
            offset?: number;
            searchQuery?: string;
        };
        url: '/v1/insights/{owner}/{slug}/coins';
    };
    export type ListCoinsResponses = {
        /**
         * A successful response.
         */
        200: insights_service.ListCoinsResponse;
    };
    export type ListCoinsResponse3 = ListCoinsResponses[keyof ListCoinsResponses];
    export type QueryData = {
        body: insights_service.InsightsServiceQueryBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/insights/{owner}/{slug}/query';
    };
    export type QueryResponses = {
        /**
         * A successful response.
         */
        200: insights_service.QueryResponse;
    };
    export type QueryResponse2 = QueryResponses[keyof QueryResponses];
}

export namespace metrics_service {
    export type GetMetricsResponse = {
        metrics?: Array<MetricInfo>;
        computeStats?: common.ComputeStats;
    };
    export type MetricInfo = {
        name?: string;
        displayName?: string;
        projectId?: string;
        contractName?: Array<string>;
        contractAddress?: Array<string>;
        chainId?: Array<string>;
        labels?: {
            [key: string]: MetricInfoLabelValues;
        };
        metadata?: MetricMetadata;
    };
    export type MetricInfoLabelValues = {
        values?: Array<string>;
        totalCount?: string;
    };
    export type MetricMetadata = {
        type?: string;
        unit?: string;
        help?: string;
        lastSeen?: string;
    };
    export type MetricsQueryResponse = {
        results?: Array<MetricsQueryResponseResult>;
    };
    export type MetricsQueryResponseMatrix = {
        samples?: Array<MetricsQueryResponseSample>;
        totalSamples?: number;
    };
    export type MetricsQueryResponseMetric = {
        name?: string;
        labels?: {
            [key: string]: string;
        };
        displayName?: string;
    };
    export type MetricsQueryResponseResult = {
        matrix?: MetricsQueryResponseMatrix;
        error?: string;
        alias?: string;
        id?: string;
        computeStats?: common.ComputeStats;
        color?: string;
    };
    export type MetricsQueryResponseSample = {
        metric?: MetricsQueryResponseMetric;
        values?: Array<MetricsQueryResponseValue>;
    };
    export type MetricsQueryResponseValue = {
        timestamp?: string;
        value?: number;
        extraValues?: Array<number>;
    };
    export type ObservabilityServiceQueryBody = {
        queries?: Array<common.Query>;
        formulas?: Array<common.Formula>;
        time?: string;
        samplesLimit?: number;
        version?: number;
        timezone?: string;
        samplesOffset?: number;
    };
    export type ObservabilityServiceQueryRangeBody = {
        queries?: Array<common.Query>;
        formulas?: Array<common.Formula>;
        samplesLimit?: number;
        timeRange: common.TimeRangeLite;
        projectId?: string;
        version?: number;
        samplesOffset?: number;
    };
    export type QueryValueResponse = {
        results?: Array<QueryValueResponseResult>;
    };
    export type QueryValueResponseResult = {
        sample?: Array<MetricsQueryResponseSample>;
        error?: string;
        alias?: string;
        id?: string;
        color?: string;
    };
    export type GetMetricsData = {
        body?: never;
        path?: never;
        query?: {
            projectId?: string;
            name?: string;
            version?: number;
            labelLimit?: string;
            labelSearchQuery?: string;
        };
        url: '/v1/metrics';
    };
    export type GetMetricsResponses = {
        /**
         * A successful response.
         */
        200: metrics_service.GetMetricsResponse;
    };
    export type GetMetricsResponse2 = GetMetricsResponses[keyof GetMetricsResponses];
    export type QueryInstantData = {
        body: metrics_service.ObservabilityServiceQueryBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/metrics/{owner}/{slug}/query';
    };
    export type QueryInstantResponses = {
        /**
         * A successful response.
         */
        200: metrics_service.QueryValueResponse;
    };
    export type QueryInstantResponse = QueryInstantResponses[keyof QueryInstantResponses];
    export type QueryRangeData = {
        body: metrics_service.ObservabilityServiceQueryRangeBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/metrics/{owner}/{slug}/query_range';
    };
    export type QueryRangeResponses = {
        /**
         * A successful response.
         */
        200: metrics_service.MetricsQueryResponse;
    };
    export type QueryRangeResponse = QueryRangeResponses[keyof QueryRangeResponses];
}

export namespace price_service {
    export type AddCoinByGeckoRequest = {
        coingeckoId?: string;
    };
    export type AddCoinByGeckoResponse = {
        status?: AddCoinByGeckoResponseStatus;
        message?: string;
        currentPrice?: number;
        timestamp?: string;
        symbol?: string;
        coins?: Array<CoinId2>;
    };
    export type AddCoinByGeckoResponseStatus = 'OK' | 'ALREADY_EXISTS' | 'MISMATCH_WITH_EXISTING' | 'GECKO_NOT_FOUND' | 'GECKO_RETURN_NON_SUPPORTED_CHAIN' | 'GECKO_HAS_DUPLICATE_SYMBOL';
    export type BatchGetPricesRequest = {
        timestamps?: Array<string>;
        coinIds?: Array<CoinId2>;
        experimentalFlag?: ExperimentalFlag;
    };
    export type BatchGetPricesResponse = {
        prices?: Array<BatchGetPricesResponseCoinPrice>;
    };
    export type BatchGetPricesResponseCoinPrice = {
        coinId?: CoinId2;
        price?: BatchGetPricesResponseCoinPricePrice;
        error?: string;
    };
    export type BatchGetPricesResponseCoinPricePrice = {
        results?: Array<GetPriceResponse>;
    };
    export type CheckLatestPriceResponse = {
        prices?: Array<CheckLatestPriceResponseCoinPrice>;
        latestPrice?: CheckLatestPriceResponseCoinPrice;
    };
    export type CheckLatestPriceResponseCoinPrice = {
        coinId?: CoinId2;
        price?: number;
        timestamp?: string;
    };
    /**
     * The identifier of a coin.
     */
    export type CoinId2 = {
        symbol?: string;
        address?: CoinIdAddressIdentifier2;
    };
    /**
     * The coin can be defined as a symbol, e.g. BTC, ETH, etc, or an address + chain.
     * The format of the chain is consistent with the Sentio internal representation.
     */
    export type CoinIdAddressIdentifier2 = {
        address?: string;
        chain?: string;
    };
    export type ExperimentalFlag = {
        enablePythSource?: boolean;
    };
    /**
     * GetPriceResponse is the response for GetPrice.
     */
    export type GetPriceResponse = {
        /**
         * Price in USD.
         */
        price?: number;
        /**
         * The actual timestamp of the price returned.
         */
        timestamp?: string;
        source?: string;
    };
    export type ListCoinsResponse2 = {
        coins?: Array<CoinId2>;
        coinAddressesInChain?: {
            [key: string]: CoinId2;
        };
    };
    export type GetPriceData = {
        body?: never;
        path?: never;
        query?: {
            /**
             * The timestamp we request the price at. Note, the price service may not have
             * the price at the exact timestamp, in which case it will return the price
             * at the closest timestamp.
             */
            timestamp?: string;
            'coinId.symbol'?: string;
            'coinId.address.address'?: string;
            'coinId.address.chain'?: string;
            source?: string;
            'experimentalFlag.enablePythSource'?: boolean;
        };
        url: '/v1/prices';
    };
    export type GetPriceResponses = {
        /**
         * A successful response.
         */
        200: price_service.GetPriceResponse;
    };
    export type GetPriceResponse2 = GetPriceResponses[keyof GetPriceResponses];
    export type AddCoinByGeckoData = {
        body: price_service.AddCoinByGeckoRequest;
        path?: never;
        query?: never;
        url: '/v1/prices/add_coin_by_gecko';
    };
    export type AddCoinByGeckoResponses = {
        /**
         * A successful response.
         */
        200: price_service.AddCoinByGeckoResponse;
    };
    export type AddCoinByGeckoResponse2 = AddCoinByGeckoResponses[keyof AddCoinByGeckoResponses];
    export type BatchGetPricesData = {
        body: price_service.BatchGetPricesRequest;
        path?: never;
        query?: never;
        url: '/v1/prices/batch';
    };
    export type BatchGetPricesResponses = {
        /**
         * A successful response.
         */
        200: price_service.BatchGetPricesResponse;
    };
    export type BatchGetPricesResponse2 = BatchGetPricesResponses[keyof BatchGetPricesResponses];
    export type CheckLatestPriceData = {
        body?: never;
        path?: never;
        query?: never;
        url: '/v1/prices/check_latest';
    };
    export type CheckLatestPriceResponses = {
        /**
         * A successful response.
         */
        200: price_service.CheckLatestPriceResponse;
    };
    export type CheckLatestPriceResponse2 = CheckLatestPriceResponses[keyof CheckLatestPriceResponses];
    export type PriceListCoinsData = {
        body?: never;
        path?: never;
        query?: {
            limit?: number;
            offset?: number;
            searchQuery?: string;
            chain?: string;
        };
        url: '/v1/prices/coins';
    };
    export type PriceListCoinsResponses = {
        /**
         * A successful response.
         */
        200: price_service.ListCoinsResponse2;
    };
    export type PriceListCoinsResponse = PriceListCoinsResponses[keyof PriceListCoinsResponses];
}

export namespace processor_service {
    export type ChainState = {
        /**
         * The chain id.
         */
        chainId?: string;
        /**
         * The most recently processed block number and block hash.
         */
        processedBlockNumber?: string;
        processedTimestampMicros?: string;
        processedBlockHash?: string;
        processedVersion?: number;
        status?: ChainStateStatus;
        updatedAt?: string;
        /**
         * The serialized templates info.
         */
        templates?: string;
        /**
         * The serialized indexer state.
         */
        indexerState?: string;
        /**
         * The serialized meter state.
         */
        meterState?: string;
        handlerStat?: string;
        initialStartBlockNumber?: string;
        estimatedLatestBlockNumber?: string;
        /**
         * To be deprecated after the migration.
         */
        trackers?: string;
    };
    export type ChainStateStatus = {
        state?: ChainStateStatusState;
        errorRecord?: common.ErrorRecord;
    };
    export type ChainStateStatusState = 'UNKNOWN' | 'ERROR' | 'CATCHING_UP' | 'PROCESSING_LATEST' | 'QUEUING';
    export type DownloadProcessorResponse = {
        url?: string;
    };
    export type GetProcessorResponse = {
        processor?: Processor;
    };
    export type GetProcessorSourceFilesResponse = {
        sourceFiles?: Array<ProcessorSourceFile>;
    };
    export type GetProcessorStatusRequestV2VersionSelector = 'ACTIVE' | 'PENDING' | 'ALL';
    export type GetProcessorStatusResponse = {
        processors?: Array<GetProcessorStatusResponseProcessorEx>;
    };
    export type GetProcessorStatusResponseProcessorEx = {
        states?: Array<ChainState>;
        processorId?: string;
        codeHash?: string;
        commitSha?: string;
        uploadedBy?: common.UserInfo;
        uploadedAt?: string;
        processorStatus?: GetProcessorStatusResponseProcessorStatus;
        version?: number;
        sdkVersion?: string;
        gitUrl?: string;
        versionState?: ProcessorVersionState;
        versionLabel?: string;
        ipfsHash?: string;
        debugFork?: string;
        cliVersion?: string;
        referenceProjectId?: string;
        warnings?: Array<string>;
        pause?: boolean;
        networkOverrides?: Array<NetworkOverride>;
    };
    export type GetProcessorStatusResponseProcessorStatus = {
        state?: GetProcessorStatusResponseProcessorStatusState;
        errorRecord?: common.ErrorRecord;
    };
    export type GetProcessorStatusResponseProcessorStatusState = 'UNKNOWN' | 'ERROR' | 'STARTING' | 'PROCESSING';
    export type GetProcessorWithProjectResponse = {
        processor?: Processor;
        project?: common.Project;
    };
    export type GetProcessorsResponse = {
        processors?: Array<Processor>;
    };
    export type NetworkOverride = {
        chain?: string;
        host?: string;
    };
    /**
     * This represents a processor which backend works on.
     */
    export type Processor = {
        /**
         * The unique processor id.
         */
        processorId?: string;
        /**
         * The project this processor belongs to.
         */
        projectId?: string;
        /**
         * The version of the code_url below.
         */
        version?: number;
        sdkVersion?: string;
        /**
         * Call should be able to fetch the code to run from code_url.
         */
        codeUrl?: string;
        chainStates?: Array<ChainState>;
        /**
         * If non empty, this is the contract associated with the processor.
         */
        contractId?: string;
        versionState?: ProcessorVersionState;
        debug?: boolean;
        /**
         * The timescale-db sharding index of this processor.
         */
        timescaleShardingIndex?: number;
        versionLabel?: string;
        ipfsHash?: string;
        debugFork?: string;
        /**
         * The created timestamp of the processor.
         */
        createdAt?: string;
        /**
         * The clickhouse sharding index of this processor.
         */
        clickhouseShardingIndex?: number;
        k8sClusterId?: number;
        enableMaterializedView?: boolean;
        referenceProjectId?: string;
        networkOverrides?: Array<NetworkOverride>;
        eventlogMigrateStatus?: number;
        eventlogVersion?: number;
        pause?: boolean;
        entitySchemaVersion?: number;
        driverVersion?: number;
        isBinary?: boolean;
    };
    export type ProcessorSourceFile = {
        path?: string;
        content?: string;
    };
    export type ProcessorVersionState = 'UNKNOWN' | 'PENDING' | 'ACTIVE' | 'OBSOLETE';
    export type UpdateChainProcessorStatusResponse = {
        [key: string]: unknown;
    };
    export type GetProcessorSourceFilesData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            /**
             * Optional version to fetch. If omitted, use latest active version.
             */
            version?: number;
        };
        url: '/v1/processors/{owner}/{slug}/source_files';
    };
    export type GetProcessorSourceFilesResponses = {
        /**
         * A successful response.
         */
        200: processor_service.GetProcessorSourceFilesResponse;
    };
    export type GetProcessorSourceFilesResponse2 = GetProcessorSourceFilesResponses[keyof GetProcessorSourceFilesResponses];
    export type GetProcessorStatusV2Data = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            /**
             *  - ACTIVE: Only active version
             * - PENDING: Only pending versions
             * - ALL: All version
             */
            version?: 'ACTIVE' | 'PENDING' | 'ALL';
        };
        url: '/v1/processors/{owner}/{slug}/status';
    };
    export type GetProcessorStatusV2Responses = {
        /**
         * A successful response.
         */
        200: processor_service.GetProcessorStatusResponse;
    };
    export type GetProcessorStatusV2Response = GetProcessorStatusV2Responses[keyof GetProcessorStatusV2Responses];
}

export namespace solidity_service {
    export type BaseChainConfig = {
        endpoint?: string;
        debugEndpoint?: string;
        sourceFetcherType?: SourceFetcherType;
        sourceFetcherEndpoint?: string;
        sourceFetcherTimeout?: string;
        sourceFetcherApiKeys?: Array<string>;
        oklinkChainShortName?: string;
    };
    export type BlockOverrides = {
        blockNumber?: string;
        timestamp?: string;
        gasLimit?: string;
        difficulty?: string;
        baseFee?: string;
        blockHash?: {
            [key: string]: string;
        };
    };
    export type BlockPrice = {
        blockNumber?: number;
        estimatedTransactionCount?: number;
        baseFeePerGas?: number;
        blobBaseFeePerGas?: number;
        estimatedPrices?: Array<EstimatedPrice>;
    };
    export type ChainIdentifier = {
        chainId?: string;
        forkId?: string;
    };
    export type CompileSourceInternalResponse = {
        failure?: Failure;
    };
    export type CompilerOptions = {
        language?: string;
        version?: string;
        settings?: Settings;
        specializations?: Specializations;
    };
    export type ContractKeyInfo = {
        preprocessKey?: string;
        compilationKey?: string;
    };
    export type CreateForkResponse = {
        fork?: Fork;
    };
    export type DecodeStateDiffResponse = {
        result?: string;
    };
    export type EstimatedPrice = {
        confidence?: number;
        price?: number;
        maxPriorityFeePerGas?: number;
        maxFeePerGas?: number;
    };
    export type EvmRawTransaction = {
        hash?: string;
        blockNumber?: string;
        isIn?: boolean;
        trace?: boolean;
        tx?: evm.Transaction;
        json?: string;
        timestamp?: string;
        transactionStatus?: number;
        methodSignature?: string;
        methodSignatureText?: string;
        abiItem?: string;
    };
    export type EvmSearchTransactionsResponse = {
        transactions?: Array<EvmRawTransaction>;
        nextPageToken?: string;
    };
    export type ExternalFork = {
        chainConfig?: BaseChainConfig;
        nodeAdditionalHeaders?: string;
    };
    export type Failure = {
        error?: string;
        reason?: string;
    };
    export type Fork = {
        id?: string;
        type?: ForkType;
        name?: string;
        extra?: string;
        managedFork?: ManagedFork;
        externalFork?: ExternalFork;
        createTime?: string;
        updateTime?: string;
    };
    export type ForkServiceCreateForkBody = {
        fork: Fork;
    };
    export type ForkServiceUpdateForkBody = {
        fork: Fork;
    };
    export type ForkType = 'MANAGED' | 'EXTERNAL';
    export type GetEstimatedGasPriceResponse = {
        system?: string;
        network?: string;
        unit?: string;
        maxPrice?: number;
        currentBlockNumber?: number;
        msSinceLastBlock?: number;
        blockPrices?: Array<BlockPrice>;
    };
    export type GetForkInfoResponse = {
        currentBlockNumber?: string;
        currentBlockTimestamp?: string;
        currentBlockHash?: string;
        hardFork?: string;
        transactionOrder?: string;
        environment?: NodeEnvironment;
        forkConfig?: NodeForkConfig;
    };
    export type GetForkResponse = {
        fork?: Fork;
    };
    export type GetSimulationBundleResponse = {
        simulations?: Array<Simulation>;
        error?: string;
    };
    export type GetSimulationResponse = {
        simulation?: Simulation;
    };
    export type GetSimulationsResponse = {
        simulations?: Array<Simulation>;
        count?: string;
        page?: number;
        pageSize?: number;
    };
    export type GetStorageSummaryInternalResponse = {
        results?: Array<StorageSummaryResult>;
    };
    export type GetTraceCallInternalRequestBundle = {
        transactions?: Array<{
            [key: string]: unknown;
        }>;
        blockOverride?: BlockOverrides;
    };
    export type GetTraceCallInternalRequestStateContext = {
        blockNumber?: string;
        transactionIndex?: number;
    };
    export type GetTraceCallInternalResponse = {
        result?: Array<Array<{
            [key: string]: unknown;
        }>>;
        outputs?: Array<Array<{
            [key: string]: unknown;
        }>>;
        error?: string;
    };
    export type GetTraceTransactionInternalResponse = {
        result?: string;
    };
    export type ListForksResponse = {
        forks?: Array<Fork>;
    };
    export type ManagedFork = {
        parentChainSpec?: ChainIdentifier;
        parentRpcEndpoint?: string;
        parentBlockNumber?: string;
        chainId?: string;
        rpcEndpoint?: string;
        version?: string;
    };
    export type Metadata = {
        useLiteralContent?: boolean;
        bytecodeHash?: string;
        appendCBOR?: boolean;
    };
    export type NodeEnvironment = {
        chainId?: string;
        baseFee?: string;
        gasLimit?: string;
        gasPrice?: string;
    };
    export type NodeForkConfig = {
        forkUrl?: string;
        forkBlockNumber?: string;
        forkRetryBackoff?: string;
    };
    export type Optimizer = {
        enabled?: boolean;
        runs?: number;
        details?: OptimizerDetails;
    };
    export type OptimizerDetails = {
        peephole?: boolean;
        jumpdestRemover?: boolean;
        yul?: boolean;
        yulDetails?: OptimizerDetailsYulDetails;
    };
    export type OptimizerDetailsYulDetails = {
        stackAllocation?: boolean;
        optimizerSteps?: string;
    };
    export type PreProcessCompilationInternalResponse = {
        preprocessedAddresses?: Array<string>;
    };
    export type Settings = {
        remappings?: Array<string>;
        optimizer?: Optimizer;
        evmVersion?: string;
        metadata?: Metadata;
        viaIR?: boolean;
        compilationTarget?: {
            [key: string]: string;
        };
    };
    export type SimulateTransactionBundleResponse = {
        bundleId?: string;
        simulations?: Array<Simulation>;
        error?: string;
    };
    export type SimulateTransactionResponse = {
        simulation?: Simulation;
    };
    export type Simulation = {
        id?: string;
        createAt?: string;
        bundleId?: string;
        networkId: string;
        chainId?: string;
        chainSpec: ChainIdentifier;
        to: string;
        input: string;
        /**
         * Can be "latest".
         */
        blockNumber: string;
        transactionIndex: string;
        from: string;
        gas: string;
        gasPrice: string;
        maxFeePerGas?: string;
        maxPriorityFeePerGas?: string;
        value: string;
        accessList?: Array<evm.AccessListItem>;
        originTxHash?: string;
        label?: string;
        stateOverrides?: {
            [key: string]: StateOverride;
        };
        sourceOverrides?: {
            [key: string]: string;
        };
        blockOverride?: BlockOverrides;
        debugDeployment?: boolean;
        result?: SimulationResult;
        sharing?: SimulationSharing;
    };
    export type SimulationResult = {
        transaction?: evm.Transaction;
        transactionReceipt?: evm.TransactionReceipt;
    };
    export type SimulationSharing = {
        isPublic?: boolean;
        id?: string;
        simulationId?: string;
    };
    export type SolidityApiServiceSimulateTransactionBody = {
        simulation: Simulation;
    };
    export type SolidityApiServiceSimulateTransactionBundleBody = {
        /**
         * For blockNumber, transactionIndex, networkId, stateOverrides and blockOverrides fields, only the first simulation takes effect.
         */
        simulations: Array<Simulation>;
    };
    export type SolidityApiServiceSimulateTransactionBundleOnForkBody = {
        /**
         * For blockNumber, transactionIndex, networkId, stateOverrides and blockOverrides fields, only the first simulation takes effect.
         */
        simulations: Array<Simulation>;
    };
    export type SolidityApiServiceSimulateTransactionOnForkBody = {
        simulation: Simulation;
    };
    export type SourceFetcherType = 'ETHERSCAN' | 'BLOCKSCOUT' | 'OKLINK' | 'ETHERSCAN_V2';
    export type SourceInfo = {
        contractName?: string;
        options?: CompilerOptions;
    };
    export type SourceMultiFile = {
        source?: {
            [key: string]: string;
        };
        compilerSettings?: string;
    };
    export type SourceSpec = {
        id?: string;
        multiFile?: SourceMultiFile;
        standardJson?: {
            [key: string]: unknown;
        };
        metadata?: {
            [key: string]: unknown;
        };
        solidityVersion?: string;
        contractName?: string;
        constructorArgs?: string;
    };
    export type Specializations = {
        constructorArguments?: string;
    };
    export type StateOverride = {
        state?: {
            [key: string]: string;
        };
        /**
         * uint256
         */
        balance?: string;
        code?: string;
    };
    export type StorageSummaryResult = {
        address?: string;
        codeAddress?: string;
        stateVariables?: Array<{
            [key: string]: unknown;
        }>;
    };
    export type UpdateForkResponse = {
        fork?: Fork;
    };
    export type GetEstimatedGasPriceData = {
        body?: never;
        path?: never;
        query?: {
            /**
             * Current support chain id: 1
             */
            chainId?: string;
        };
        url: '/v1/solidity/estimated_gas_price';
    };
    export type GetEstimatedGasPriceResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetEstimatedGasPriceResponse;
    };
    export type GetEstimatedGasPriceResponse2 = GetEstimatedGasPriceResponses[keyof GetEstimatedGasPriceResponses];
    export type ListForksData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork';
    };
    export type ListForksResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.ListForksResponse;
    };
    export type ListForksResponse2 = ListForksResponses[keyof ListForksResponses];
    export type CreateForkData = {
        body: solidity_service.ForkServiceCreateForkBody;
        path: {
            owner: string;
            slug: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork';
    };
    export type CreateForkResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.CreateForkResponse;
    };
    export type CreateForkResponse2 = CreateForkResponses[keyof CreateForkResponses];
    export type SimulateTransactionOnForkData = {
        body: solidity_service.SolidityApiServiceSimulateTransactionOnForkBody;
        path: {
            owner: string;
            slug: string;
            forkId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{forkId}/simulation';
    };
    export type SimulateTransactionOnForkResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.SimulateTransactionResponse;
    };
    export type SimulateTransactionOnForkResponse = SimulateTransactionOnForkResponses[keyof SimulateTransactionOnForkResponses];
    export type SimulateTransactionBundleOnForkData = {
        body: solidity_service.SolidityApiServiceSimulateTransactionBundleOnForkBody;
        path: {
            owner: string;
            slug: string;
            forkId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{forkId}/simulation_bundle';
    };
    export type SimulateTransactionBundleOnForkResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.SimulateTransactionBundleResponse;
    };
    export type SimulateTransactionBundleOnForkResponse = SimulateTransactionBundleOnForkResponses[keyof SimulateTransactionBundleOnForkResponses];
    export type GetForkData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            id: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{id}';
    };
    export type GetForkResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetForkResponse;
    };
    export type GetForkResponse2 = GetForkResponses[keyof GetForkResponses];
    export type UpdateForkData = {
        body: solidity_service.ForkServiceUpdateForkBody;
        path: {
            owner: string;
            slug: string;
            id: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{id}';
    };
    export type UpdateForkResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.UpdateForkResponse;
    };
    export type UpdateForkResponse2 = UpdateForkResponses[keyof UpdateForkResponses];
    export type GetForkInfoData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            id: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{id}/info';
    };
    export type GetForkInfoResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetForkInfoResponse;
    };
    export type GetForkInfoResponse2 = GetForkInfoResponses[keyof GetForkInfoResponses];
    export type SearchTransactionsData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            chainId?: Array<string>;
            address?: Array<string>;
            includeDirect?: boolean;
            includeTrace?: boolean;
            includeIn?: boolean;
            includeOut?: boolean;
            startBlock?: string;
            endBlock?: string;
            startTimestamp?: string;
            endTimestamp?: string;
            transactionStatus?: Array<number>;
            methodSignature?: string;
            limit?: number;
            pageToken?: string;
        };
        url: '/v1/solidity/{owner}/{slug}/search_transactions';
    };
    export type SearchTransactionsResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.EvmSearchTransactionsResponse;
    };
    export type SearchTransactionsResponse = SearchTransactionsResponses[keyof SearchTransactionsResponses];
    export type GetSimulationsData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: {
            labelContains?: string;
            page?: number;
            pageSize?: number;
        };
        url: '/v1/solidity/{owner}/{slug}/simulation';
    };
    export type GetSimulationsResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetSimulationsResponse;
    };
    export type GetSimulationsResponse2 = GetSimulationsResponses[keyof GetSimulationsResponses];
    export type GetSimulationData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            simulationId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/simulation/{simulationId}';
    };
    export type GetSimulationResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetSimulationResponse;
    };
    export type GetSimulationResponse2 = GetSimulationResponses[keyof GetSimulationResponses];
    export type GetSimulationBundleInProjectData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            bundleId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/simulation_bundle/{bundleId}';
    };
    export type GetSimulationBundleInProjectResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.GetSimulationBundleResponse;
    };
    export type GetSimulationBundleInProjectResponse = GetSimulationBundleInProjectResponses[keyof GetSimulationBundleInProjectResponses];
    export type SimulateTransactionData = {
        body: solidity_service.SolidityApiServiceSimulateTransactionBody;
        path: {
            owner: string;
            slug: string;
            chainId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/{chainId}/simulation';
    };
    export type SimulateTransactionResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.SimulateTransactionResponse;
    };
    export type SimulateTransactionResponse2 = SimulateTransactionResponses[keyof SimulateTransactionResponses];
    export type SimulateTransactionBundleData = {
        body: solidity_service.SolidityApiServiceSimulateTransactionBundleBody;
        path: {
            owner: string;
            slug: string;
            chainId: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/{chainId}/simulation_bundle';
    };
    export type SimulateTransactionBundleResponses = {
        /**
         * A successful response.
         */
        200: solidity_service.SimulateTransactionBundleResponse;
    };
    export type SimulateTransactionBundleResponse2 = SimulateTransactionBundleResponses[keyof SimulateTransactionBundleResponses];
}

export namespace web_service {
    export type Chart = {
        type?: ChartType2;
        queries?: Array<common.Query>;
        formulas?: Array<common.Formula>;
        config?: ChartConfig;
        note?: Note;
        datasourceType?: ChartDataSourceType;
        segmentationQueries?: Array<common.SegmentationQuery>;
        insightsQueries?: Array<insights_service.QueryRequestQuery>;
        eventLogsConfig?: EventLogsConfig;
        retentionQuery?: common.RetentionQuery;
        sqlQuery?: string;
        sqlQueryId?: string;
        sqlExecuteEngine?: analytic_service.ExecuteEngine;
    };
    export type ChartDataSourceType = 'METRICS' | 'NOTES' | 'ANALYTICS' | 'INSIGHTS' | 'EVENTS' | 'RETENTION' | 'SQL';
    export type ChartConfig = {
        yAxis?: ChartConfigYAxisConfig;
        barGauge?: ChartConfigBarGaugeConfig;
        valueConfig?: ChartConfigValueConfig;
        timeRangeOverride?: ChartConfigTimeRangeOverride;
        tableConfig?: ChartConfigTableConfig;
        queryValueConfig?: ChartConfigQueryValueConfig;
        pieConfig?: ChartConfigPieConfig;
        markers?: Array<ChartConfigMarker>;
        lineConfig?: ChartConfigLineConfig;
        xAxis?: ChartConfigXAxisConfig;
        labelConfig?: ChartConfigLabelConfig;
        scatterConfig?: ChartConfigScatterConfig;
        seriesConfig?: ChartConfigSeriesConfig;
        dataConfig?: ChartConfigDataConfig;
    };
    export type ChartConfigBarGaugeConfig = {
        direction?: ChartConfigDirection;
        calculation?: ChartConfigCalculation;
        sort?: ChartConfigSort;
    };
    export type ChartConfigCalculation = 'LAST' | 'FIRST' | 'MEAN' | 'TOTAL' | 'ALL' | 'MIN' | 'MAX';
    export type ChartConfigColorTheme = {
        textColor?: string;
        backgroundColor?: string;
        themeType?: string;
    };
    export type ChartConfigColumnSort = {
        column?: string;
        orderDesc?: boolean;
    };
    export type ChartConfigCompareTime = {
        ago?: common.Duration;
    };
    export type ChartConfigDataConfig = {
        seriesLimit?: number;
    };
    export type ChartConfigDirection = 'HORIZONTAL' | 'VERTICAL';
    export type ChartConfigLabelConfig = {
        columns?: Array<ChartConfigLabelConfigColumn>;
        alias?: string;
    };
    export type ChartConfigLabelConfigColumn = {
        name?: string;
        showLabel?: boolean;
        showValue?: boolean;
    };
    export type ChartConfigLineConfig = {
        style?: ChartConfigLineConfigStyle;
        smooth?: boolean;
    };
    export type ChartConfigLineConfigStyle = 'Solid' | 'Dotted';
    export type ChartConfigMappingRule = {
        comparison?: string;
        value?: number;
        text?: string;
        colorTheme?: ChartConfigColorTheme;
    };
    export type ChartConfigMarker = {
        type?: ChartConfigMarkerType;
        value?: number;
        color?: string;
        label?: string;
        valueX?: string;
    };
    export type ChartConfigMarkerType = 'LINE' | 'AREA' | 'LINEX';
    export type ChartConfigPieConfig = {
        pieType?: ChartConfigPieConfigPieType;
        showPercent?: boolean;
        showValue?: boolean;
        calculation?: ChartConfigCalculation;
        absValue?: boolean;
    };
    export type ChartConfigPieConfigPieType = 'Pie' | 'Donut';
    export type ChartConfigQueryValueConfig = {
        colorTheme?: ChartConfigColorTheme;
        showBackgroundChart?: boolean;
        calculation?: ChartConfigCalculation;
        seriesCalculation?: ChartConfigCalculation;
    };
    export type ChartConfigScatterConfig = {
        symbolSize?: string;
        color?: string;
        minSize?: number;
        maxSize?: number;
    };
    export type ChartConfigSeriesConfig = {
        series?: {
            [key: string]: ChartConfigSeriesConfigSeries;
        };
    };
    export type ChartConfigSeriesConfigSeries = {
        type?: ChartType2;
    };
    export type ChartConfigSort = {
        sortBy?: ChartConfigSortBy;
        orderDesc?: boolean;
    };
    export type ChartConfigSortBy = 'ByName' | 'ByValue';
    export type ChartConfigTableConfig = {
        calculation?: ChartConfigCalculation;
        showColumns?: {
            [key: string]: boolean;
        };
        sortColumns?: Array<ChartConfigColumnSort>;
        columnOrders?: Array<string>;
        columnWidths?: {
            [key: string]: number;
        };
        showPlainData?: boolean;
        calculations?: {
            [key: string]: ChartConfigCalculation;
        };
        valueConfigs?: {
            [key: string]: ChartConfigValueConfig;
        };
        rowLimit?: number;
    };
    export type ChartConfigTimeRangeOverride = {
        enabled?: boolean;
        timeRange?: common.TimeRange;
        compareTime?: ChartConfigCompareTime;
    };
    export type ChartConfigValueConfig = {
        valueFormatter?: ChartConfigValueFormatter;
        showValueLabel?: boolean;
        maxSignificantDigits?: number;
        dateFormat?: string;
        mappingRules?: Array<ChartConfigMappingRule>;
        style?: ChartConfigValueConfigStyle;
        maxFractionDigits?: number;
        precision?: number;
        currencySymbol?: string;
        tooltipTotal?: boolean;
        prefix?: string;
        suffix?: string;
    };
    export type ChartConfigValueConfigStyle = 'Standard' | 'Compact' | 'Scientific' | 'Percent' | 'Currency' | 'None';
    export type ChartConfigValueFormatter = 'NumberFormatter' | 'DateFormatter' | 'StringFormatter';
    export type ChartConfigXAxisConfig = {
        type?: string;
        min?: string;
        max?: string;
        scale?: boolean;
        name?: string;
        column?: string;
        sort?: ChartConfigSort;
        format?: string;
    };
    export type ChartConfigYAxisConfig = {
        min?: string;
        max?: string;
        scale?: boolean;
        stacked?: string;
        column?: string;
        name?: string;
    };
    export type ChartType2 = 'LINE' | 'AREA' | 'BAR' | 'BAR_GAUGE' | 'TABLE' | 'QUERY_VALUE' | 'PIE' | 'NOTE' | 'SCATTER';
    export type Dashboard = {
        id?: string;
        name?: string;
        projectId?: string;
        description?: string;
        createdAt?: string;
        updatedAt?: string;
        panels?: {
            [key: string]: Panel;
        };
        layouts?: DashboardResponsiveLayouts;
        extra?: DashboardExtra;
        sharing?: DashboardSharing;
        default?: boolean;
        isPinned?: boolean;
        visibility?: DashboardDashboardVisibility;
        ownerId?: string;
        tags?: Array<string>;
        url?: string;
        projectOwner?: string;
        projectSlug?: string;
        createPanels?: Array<string>;
        editPanels?: Array<string>;
    };
    export type DashboardDashboardVisibility = 'INTERNAL' | 'PRIVATE' | 'PUBLIC';
    export type DashboardExtra = {
        templateVariables?: {
            [key: string]: DashboardExtraTemplateVariable;
        };
        templateViews?: Array<DashboardExtraTemplateView>;
    };
    export type DashboardExtraTemplateVariable = {
        field?: string;
        defaultValue?: string;
        sourceName?: string;
        options?: Array<string>;
    };
    export type DashboardExtraTemplateView = {
        values?: {
            [key: string]: string;
        };
    };
    export type DashboardLayouts = {
        layouts?: Array<DashboardLayoutsLayout>;
    };
    export type DashboardLayoutsLayout = {
        i?: string;
        x?: number;
        y?: number;
        w?: number;
        h?: number;
    };
    export type DashboardResponsiveLayouts = {
        responsiveLayouts?: {
            [key: string]: DashboardLayouts;
        };
    };
    export type DashboardHistory = {
        id?: number;
        dashboardId?: string;
        version?: number;
        name?: string;
        description?: string;
        projectId?: string;
        layouts?: DashboardResponsiveLayouts;
        extra?: DashboardExtra;
        tags?: Array<string>;
        url?: string;
        default?: boolean;
        isPinned?: boolean;
        ownerId?: string;
        visibility?: DashboardDashboardVisibility;
        createdAt?: string;
        createdById?: string;
    };
    export type DashboardSharing = {
        id?: string;
        dashboardId?: string;
        isPublic?: boolean;
        viewers?: Array<string>;
        config?: SharingConfig;
    };
    export type EventLogsConfig = {
        columnsConfig?: common.EventLogConfig;
        timeRangeOverride?: EventLogsConfigTimeRangeOverride;
        query?: string;
        sourceName?: string;
    };
    export type EventLogsConfigTimeRangeOverride = {
        enabled?: boolean;
        timeRange?: common.TimeRange;
    };
    export type ExportDashboardResponse = {
        dashboardJson?: {
            [key: string]: unknown;
        };
    };
    export type GetDashboardHistoryResponse = {
        histories?: Array<DashboardHistory>;
        total?: number;
    };
    export type GetDashboardResponse = {
        dashboards?: Array<Dashboard>;
        permissions?: Array<common.Permission>;
    };
    export type GetProjectListResponse = {
        projects?: Array<common.Project>;
        sharedProjects?: Array<common.Project>;
        orgProjects?: Array<common.Project>;
    };
    export type GetProjectResponse = {
        project?: common.Project;
        permissions?: Array<common.Permission>;
    };
    export type ImportDashboardRequest = {
        /**
         * The id of the target dashboard to import into.
         */
        dashboardId: string;
        /**
         * The json data of a previously exported dashboard.
         */
        dashboardJson: {
            [key: string]: unknown;
        };
        /**
         * Override the layout of target dashboard.
         */
        overrideLayouts?: boolean;
    };
    export type ImportDashboardResponse = {
        dashboard?: Dashboard;
    };
    export type ImportProjectResponse = {
        imports?: Array<common.ImportedProject>;
    };
    export type Note = {
        content?: string;
        fontSize?: NoteFontSize;
        textAlign?: NoteAlignment;
        verticalAlign?: NoteVerticalAlignment;
        backgroundColor?: string;
        textColor?: string;
    };
    export type NoteAlignment = 'LEFT' | 'CENTER' | 'RIGHT';
    export type NoteFontSize = 'MD' | 'SM' | 'LG' | 'XL' | 'XXL';
    export type NoteVerticalAlignment = 'TOP' | 'MIDDLE' | 'BOTTOM';
    export type Panel = {
        id?: string;
        name?: string;
        dashboardId?: string;
        chart?: Chart;
        creator?: common.UserInfo;
        updater?: common.UserInfo;
    };
    export type ProjectOwnerAndSlug = {
        ownerName?: string;
        slug?: string;
    };
    export type SharingConfig = {
        isReadonly?: boolean;
        hideModifiers?: boolean;
    };
    export type WebServiceImportProjectBody = {
        name?: string;
        importProject?: ProjectOwnerAndSlug;
        importProjects?: Array<ProjectOwnerAndSlug>;
    };
    export type ListDashboardsData = {
        body?: never;
        path?: never;
        query?: {
            /**
             * filter the dashboard by id
             */
            dashboardId?: string;
            /**
             * filter the dashboard by project id
             */
            projectId?: string;
            /**
             * username or organization name
             */
            ownerName?: string;
            /**
             * project slug
             */
            slug?: string;
        };
        url: '/v1/dashboards';
    };
    export type ListDashboardsResponses = {
        /**
         * A successful response.
         */
        200: GetDashboardResponse;
    };
    export type ListDashboardsResponse = ListDashboardsResponses[keyof ListDashboardsResponses];
    export type ImportDashboardData = {
        body: ImportDashboardRequest;
        path?: never;
        query?: never;
        url: '/v1/dashboards/json';
    };
    export type ImportDashboardResponses = {
        /**
         * A successful response.
         */
        200: ImportDashboardResponse;
    };
    export type ImportDashboardResponse2 = ImportDashboardResponses[keyof ImportDashboardResponses];
    export type DeleteDashboardData = {
        body?: never;
        path: {
            /**
             * filter the dashboard by id
             */
            dashboardId: string;
        };
        query?: {
            /**
             * filter the dashboard by project id
             */
            projectId?: string;
            /**
             * username or organization name
             */
            ownerName?: string;
            /**
             * project slug
             */
            slug?: string;
        };
        url: '/v1/dashboards/{dashboardId}';
    };
    export type DeleteDashboardResponses = {
        /**
         * A successful response.
         */
        200: Dashboard;
    };
    export type DeleteDashboardResponse = DeleteDashboardResponses[keyof DeleteDashboardResponses];
    export type GetDashboardData = {
        body?: never;
        path: {
            /**
             * filter the dashboard by id
             */
            dashboardId: string;
        };
        query?: {
            /**
             * filter the dashboard by project id
             */
            projectId?: string;
            /**
             * username or organization name
             */
            ownerName?: string;
            /**
             * project slug
             */
            slug?: string;
        };
        url: '/v1/dashboards/{dashboardId}';
    };
    export type GetDashboardResponses = {
        /**
         * A successful response.
         */
        200: GetDashboardResponse;
    };
    export type GetDashboardResponse2 = GetDashboardResponses[keyof GetDashboardResponses];
    export type GetDashboardHistoryData = {
        body?: never;
        path: {
            dashboardId: string;
        };
        query?: {
            limit?: number;
            offset?: number;
        };
        url: '/v1/dashboards/{dashboardId}/history';
    };
    export type GetDashboardHistoryResponses = {
        /**
         * A successful response.
         */
        200: GetDashboardHistoryResponse;
    };
    export type GetDashboardHistoryResponse2 = GetDashboardHistoryResponses[keyof GetDashboardHistoryResponses];
    export type ExportDashboardData = {
        body?: never;
        path: {
            dashboardId: string;
        };
        query?: never;
        url: '/v1/dashboards/{dashboardId}/json';
    };
    export type ExportDashboardResponses = {
        /**
         * A successful response.
         */
        200: ExportDashboardResponse;
    };
    export type ExportDashboardResponse2 = ExportDashboardResponses[keyof ExportDashboardResponses];
    export type GetProjectData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/project/{owner}/{slug}';
    };
    export type GetProjectResponses = {
        /**
         * A successful response.
         */
        200: GetProjectResponse;
    };
    export type GetProjectResponse2 = GetProjectResponses[keyof GetProjectResponses];
    export type GetImportedProjectData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/project/{owner}/{slug}/importprojects';
    };
    export type GetImportedProjectResponses = {
        /**
         * A successful response.
         */
        200: ImportProjectResponse;
    };
    export type GetImportedProjectResponse = GetImportedProjectResponses[keyof GetImportedProjectResponses];
    export type ImportProjectData = {
        body: WebServiceImportProjectBody;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: never;
        url: '/v1/project/{owner}/{slug}/importprojects';
    };
    export type ImportProjectResponses = {
        /**
         * A successful response.
         */
        200: ImportProjectResponse;
    };
    export type ImportProjectResponse2 = ImportProjectResponses[keyof ImportProjectResponses];
    export type UnImportProjectData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            /**
             * username or organization name of the imported project
             */
            unimportOwner: string;
            /**
             * slug of the imported project
             */
            unimportSlug: string;
        };
        query?: never;
        url: '/v1/project/{owner}/{slug}/unimportprojects/{unimportOwner}/{unimportSlug}';
    };
    export type UnImportProjectResponses = {
        /**
         * A successful response.
         */
        200: ImportProjectResponse;
    };
    export type UnImportProjectResponse = UnImportProjectResponses[keyof UnImportProjectResponses];
    export type GetProjectListData = {
        body?: never;
        path?: never;
        query?: {
            userId?: string;
            organizationId?: string;
        };
        url: '/v1/projects';
    };
    export type GetProjectListResponses = {
        /**
         * A successful response.
         */
        200: GetProjectListResponse;
    };
    export type GetProjectListResponse2 = GetProjectListResponses[keyof GetProjectListResponses];
    export type ListDashboards2Data = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
        };
        query?: {
            /**
             * filter the dashboard by id
             */
            dashboardId?: string;
            /**
             * filter the dashboard by project id
             */
            projectId?: string;
        };
        url: '/v1/projects/{owner}/{slug}/dashboards';
    };
    export type ListDashboards2Responses = {
        /**
         * A successful response.
         */
        200: GetDashboardResponse;
    };
    export type ListDashboards2Response = ListDashboards2Responses[keyof ListDashboards2Responses];
    export type GetDashboard2Data = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            /**
             * filter the dashboard by id
             */
            dashboardId: string;
        };
        query?: {
            /**
             * filter the dashboard by project id
             */
            projectId?: string;
        };
        url: '/v1/projects/{owner}/{slug}/dashboards/{dashboardId}';
    };
    export type GetDashboard2Responses = {
        /**
         * A successful response.
         */
        200: GetDashboardResponse;
    };
    export type GetDashboard2Response = GetDashboard2Responses[keyof GetDashboard2Responses];
}

export namespace rul_service {
    export type DeleteAlertRuleData = {
        body?: never;
        path: {
            id: string;
        };
        query?: never;
        url: '/v1/alerts/rule/{id}';
    };
    export type DeleteAlertRuleResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type DeleteAlertRuleResponse = DeleteAlertRuleResponses[keyof DeleteAlertRuleResponses];
}

export namespace {owner_service {
    export type CancelSqlQueryData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            executionId: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
            /**
             * version of the datasource, default to the active version if not provided
             */
            version?: number;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/cancel_query/{executionId}';
    };
    export type CancelSqlQueryResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type CancelSqlQueryResponse = CancelSqlQueryResponses[keyof CancelSqlQueryResponses];
    export type DeleteRefreshableMaterializedViewData = {
        body?: never;
        path: {
            /**
             * username or organization name
             */
            owner: string;
            /**
             * project slug
             */
            slug: string;
            name: string;
        };
        query?: {
            /**
             * use project id if project_owner and project_slug are not provided
             */
            projectId?: string;
        };
        url: '/v1/analytics/{owner}/{slug}/sql/refreshable_materialized_view/{name}';
    };
    export type DeleteRefreshableMaterializedViewResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type DeleteRefreshableMaterializedViewResponse = DeleteRefreshableMaterializedViewResponses[keyof DeleteRefreshableMaterializedViewResponses];
    export type ActivatePendingVersionData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
        };
        query?: never;
        url: '/v1/processors/{owner}/{slug}/activate_pending';
    };
    export type ActivatePendingVersionResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type ActivatePendingVersionResponse = ActivatePendingVersionResponses[keyof ActivatePendingVersionResponses];
    export type DeleteForkData = {
        body?: never;
        path: {
            owner: string;
            slug: string;
            id: string;
        };
        query?: never;
        url: '/v1/solidity/{owner}/{slug}/fork/{id}';
    };
    export type DeleteForkResponses = {
        /**
         * A successful response.
         */
        200: {
            [key: string]: unknown;
        };
    };
    export type DeleteForkResponse = DeleteForkResponses[keyof DeleteForkResponses];
}

export type ClientOptions = {
    baseUrl: 'https://api.sentio.xyz' | (string & {});
};